<?php

/**
 * @file
 * Module contained miscelanious helper functions and hooks.
 */


/**
 * Implements hook_form_alter().
 *
 * @param array &$form
 *   Array with declared form.
 *
 * @param array &$form_state
 *   Array with current form state.
 *
 * @param string $form_id
 *   Form ID.
 *
 * @return void
 *   Return nothing.
 */
function gv_misc_form_alter(&$form, &$form_state, $form_id) {
  // dpm($form_id);dpm($form);
  // Unlink Ckeditor from the comment input form.
  if($form['#id'] == 'comment-form') {
    $form['comment_body']['und'][0]['#type'] = 'textarea';
  }
  if (isset($form['#node']) && $form_id == $form['#node']->type .'_node_form') {
    $form['body']['und']['0']['#format'] = "full_html";
    //$form['field_custom_php_code']['und']['0']['#format'] = "php_code";
  }
}


/**
 * Returns topics list for a specific content type. 
 * 
 * Allows to use same topics for News, articles, etc.
 */
function gv_misc_getTopics($content_type, $base_url = NULL, $limit = NULL) {
  $topics = NULL;
  $voc = taxonomy_vocabulary_machine_name_load(TOPICS);
  
  // Old style query, for reference.
  // $results = db_query("SELECT td.name, COUNT(n.nid) AS count FROM {taxonomy_term_data} td LEFT JOIN {taxonomy_index} ti ON ti.tid = td.tid INNER JOIN {node} n ON (n.nid = ti.nid AND n.type = :type) WHERE td.vid = :vid GROUP BY td.name LIMIT $limit", array(':vid' => $voc->vid, ':type' => $content_type));
    
  $types = array();

  $query = db_select('taxonomy_term_data', 'td')
        ->fields('td', array('name', 'tid'));
  $query->leftJoin('taxonomy_index', 'ti', 'ti.tid = td.tid');
  $query->leftJoin('node', 'n', 'n.nid = ti.nid');
  $query->where('n.nid = ti.nid AND n.type = :type', array(':type' => $content_type))
        ->addExpression('COUNT(n.nid)', 'count');
  $query->groupBy('td.name');
  if ($limit) {
    $query->range(0, $limit);
  }
  $results = $query->execute();

  foreach($results as $result) {
    // Translate terms to the current language.
    // $result->name = i18n_string_translate(array('taxonomy', 'term', $result->tid, 'name'), $result->name);
    $base_url = trim($base_url, '/');
    $result->link = array('link_title' => $result->name, 'href' => $base_url . '/' . urldecode(drupal_strtolower($result->name)));
    $topics[] = (array) $result;
  }
  return $topics;
}


/**
 * Implements hook_theme().
 */
function gv_misc_theme($existing, $type, $theme, $path) {
  return array(
     'gv_misc_submenuSimple' => array(
          'variables' => array('vars' => null),
          //'template' => 'gv_misc_home',
        ),
  );
}


/**
 * Simple theming of nested submenu.
 */
function theme_gv_misc_submenuSimple($vars) {
  if(empty($vars['submenu']['below'])) {
    return NULL;
  }
  $level = isset($vars['level']) ? $vars['level'] : 0;
  $class = isset($vars['class']) ? $vars['class'] : 'om-links';
  $delimiter = isset($vars['delimiter']) ? $vars['delimiter'] : '';
  $out = '<ul class="gv ' . $class . ' lvl-' . $level . '">';
  $count = 0;
  foreach ($vars['submenu']['below'] as $submenu) {
    if (isset($submenu['link']['hidden']) && $submenu['link']['hidden']) {
      continue;
    }
    $out .= ($count ? $delimiter : '') . '<li>';
    if($level) {
      for ($i = 0; $i < $level; $i++ ) {
        $out .= '--';
      }
    }
    $title = t($submenu['link']['link_title']);
    if(isset($submenu['count']) && $submenu['count']) {
      $title .= ' (' . $submenu['count'] . ')';
    }
    // If the field Description has '<nolink>' don't show link for this item
    if(isset($submenu['link']['localized_options']['attributes']['title']) && strtolower($submenu['link']['localized_options']['attributes']['title']) == '<nolink>') {
      $out .= $title;
    }
    else {
      $out .= l($title, $submenu['link']['href']);
    }
    $out .= '</li>';
    if (!empty($submenu['below'])) {
      // Recursion call.
      $out .= theme('gv_misc_submenuSimple', array('submenu' => $submenu, 'level' => ($level + 1), 'class' => $class, 'delimiter' => $delimiter ));
    }
    $count++;
  }
  $out .= '</ul>';
  return $out;
}


/**
 * Returns all available providers aray with nid => title.
 */
function gv_misc_getProviders(&$providers, $scope = 'all') {
  if ($scope == 'all') {
    $data = db_select('node', 'n')
          ->fields('n', array('nid', 'title'))
          ->condition('type', 'provider')
          ->execute();
    foreach($data as $provider) {
      $providers[$provider->nid] = $provider->title;
    }
  }
}


/**
 * Implements hook_token_info().
 */
function gv_misc_token_info() {
  // Defines new torens group 'Provider tokens'
  $info['types']['provider'] = array(
    'name' => t('Provider tokens'),
    'description' => t('Tokens related to providers.'),
    //'needs-data' => 'provider',
  );

  // Tokens for the Title token type.
  $info['tokens']['provider']['provider-title'] = array(
    'name' => t('Provider title'),
    'description' => t("Title of the provider chosen from select list or from a custom field if its provided."),
  );
  
  $info['tokens']['node']['provider'] = array(
    'name' => t('Provider title'),
    'description' => t('Title of the provider chosen from select list or from a custom field if its provided...'),
  );

  return $info;
}


/**
 * Implements hook_tokens().
 */
function gv_misc_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  $sanitize = !empty($options['sanitize']);

  // Text format tokens.
  if ($type == 'provider' && !empty($data['provider'])) {
    $format = $data['provider'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'provider-title':
          $replacements[$original] = 'pro' . time();
          break;
      }
    }
  }
  
  // Node tokens.
  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'provider':
          //$type_name = node_type_get_name($node);
          $replacements[$original] = 'pro';//$sanitize ? check_plain($type_name) : $type_name;
          break;
      }
    }

    // Chained token relationships.
//    if (!empty($node->tnid) && ($source_tokens = token_find_with_prefix($tokens, 'source')) && $source_node = node_load($node->tnid)) {
//      $replacements += token_generate('node', $source_tokens, array('node' => $source_node), $options);
//    }
//    if (($node_type_tokens = token_find_with_prefix($tokens, 'content-type')) && $node_type = node_type_load($node->type)) {
//      $replacements += token_generate('content-type', $node_type_tokens, array('node_type' => $node_type), $options);
//    }
//    if (($url_tokens = token_find_with_prefix($tokens, 'url'))) {
//      $replacements += token_generate('url', $url_tokens, entity_uri('node', $node), $options);
//    }
  }
  
  return $replacements;
}
